<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>유한울 매뉴팩처링</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    :root{
      --ui-bg: rgba(20,20,20,.8);
      --ui-fg:#fff;
      --accent:#7dd3fc;
      --btn-border:#333; /* 버튼 테두리 통일 */
    }
    *{ box-sizing:border-box; font-weight:inherit; }
    html,body{
      height:100%; margin:0; background:#000; color:#fff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Apple SD Gothic Neo,"Noto Sans KR",sans-serif;
      font-weight:700;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    .wrap{ position:relative; width:100%; height:100%; overflow:hidden; background:#000; }
    video#video{
      position:absolute; inset:0; margin:auto; width:100%; height:100%; object-fit:cover;
      transform: scaleX(-1); filter:brightness(.9) contrast(1.1) saturate(1.05);
      opacity:.25; pointer-events:none;
    }
    canvas#paint{ position:absolute; inset:0; width:100%; height:100%; touch-action:none; }

    /* 상단: 좌 상태, 중앙(삭제됨 자리), 우 도움말 */
    .topline{
      position:absolute; top:12px; left:12px; right:12px;
      display:grid; grid-template-columns:auto 1fr auto; gap:8px; align-items:start; /* 8px로 균일 조정 */
      pointer-events:none;
    }

    /* 상태 박스: 내부도 8px 간격 */
    .status{
      display:inline-flex; flex-direction:column; gap:8px;
      background:var(--ui-bg); color:var(--ui-fg);
      padding:10px 12px; border-radius:12px; font-size:12px; line-height:1.4;
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .status .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .status .msg{ opacity:.95; }

    .pill{ display:inline-block; padding:2px 6px; border-radius:999px; }
    .ok{background:#073}.warn{background:#735d00}.bad{background:#600}

    /* 도움말 패널 */
    .help{
      background:var(--ui-bg); color:var(--ui-fg);
      padding:10px 12px; border-radius:12px; font-size:12px; line-height:1.45;
      max-width:min(420px,34vw); backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .help pre{ margin:0; font:inherit; white-space:pre-wrap; }

    .toolbar{
      position:absolute; left:50%; transform:translateX(-50%); bottom:16px;
      display:flex; gap:10px; align-items:center;
      background:var(--ui-bg); color:var(--ui-fg); padding:10px 12px; border-radius:14px;
      backdrop-filter: blur(10px); box-shadow: 0 6px 20px rgba(0,0,0,.35); user-select:none;
    }
    .colors{display:flex; gap:6px;}
    .swatch{
      width:22px;height:22px;border-radius:50%; cursor:pointer; border:2px solid rgba(255,255,255,.6);
      outline:2px solid transparent; outline-offset:2px;
    }
    .swatch.active{ outline-color:var(--accent) }
    .group{display:flex;gap:8px;align-items:center}
    .btn{ height:32px; padding:0 10px; border-radius:10px; background:#111; color:#fff; border:1px solid var(--btn-border); cursor:pointer; }
    .btn.ghost{ background:transparent; border:1px solid var(--btn-border); } /* 테두리 색 통일 */
    .btn.toggled{ outline:2px solid var(--accent); outline-offset:2px; }
    .slider{ width:120px; accent-color:var(--accent); }
    .sep{width:1px;height:22px;background:#444; margin:0 4px}
    .cursor{
      position:absolute; width:14px;height:14px;border:2px solid #fff;border-radius:50%; pointer-events:none;
      transform:translate(-50%,-50%); mix-blend-mode:difference;
    }
    @media (max-width: 1024px){ }
    @media (max-width: 720px){
      .slider{ width:90px }
      .help{ display:none } /* 작은 화면에서는 숨김 */
    }
  </style>
</head>
<body>
<div class="wrap" id="app">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="paint"></canvas>

  <!-- 상단 UI: 상태(좌) | (중앙 배너 삭제) | 도움말(우) -->
  <div class="topline">
    <div class="status" id="statusBox">
      <div class="row">
        <span class="pill ok" id="sCam">CAM?</span>
        <span class="pill bad" id="sLib">LIB</span>
        <span class="pill bad" id="sModel">MODEL</span>
        <span class="pill bad" id="sTrack">HANDS:0</span>
      </div>
      <div class="msg" id="sMsg">초기화 중…</div>
    </div>

    <!-- 중앙 배너 제거: 의도적으로 비워둠 -->
    <div></div>

    <div class="help" id="helpPanel">
      <pre><span style="color: #ffd400;">손동작 안내</span>
• 엄지+검지: 그리기
• 엄지+중지: 지우개 토글
• 엄지+약지: 되돌리기
• 엄지+소지: 색상 순환</pre>
    </div>
  </div>

  <!-- 손가락 위치 표시용 커서 -->
  <div class="cursor" id="cursor0" hidden></div>
  <div class="cursor" id="cursor1" hidden></div>

  <div class="toolbar">
    <div class="group colors" id="colors"></div>
    <div class="group">
      <input type="range" id="size" class="slider" min="1" max="100" value="8" />
      <span id="sizeLabel">8px</span>
    </div>
    <div class="sep"></div>
    <div class="group">
      <button class="btn" id="eraserBtn" title="E">지우개</button>
      <button class="btn ghost" id="undoBtn" title="U">되돌리기</button>
      <button class="btn ghost" id="clearBtn">초기화</button>
      <button class="btn" id="saveBtn" title="S">저장</button>
    </div>
  </div>
</div>

<script type="module">
const el = (id)=>document.getElementById(id);
const video = el('video'), paint = el('paint');
const sCam = el('sCam'), sLib=el('sLib'), sModel=el('sModel'), sTrack=el('sTrack'), sMsg=el('sMsg');
const colorsEl = el('colors'), sizeEl=el('size'), sizeLabel=el('sizeLabel');
const eraserBtn = el('eraserBtn'), undoBtn=el('undoBtn'), clearBtn=el('clearBtn'), saveBtn=el('saveBtn');
const cursors = [el('cursor0'), el('cursor1')];

const DPR = Math.min(2, window.devicePixelRatio || 1);
let W=0, H=0;

/* Drawing State */
const palette = ['#ffffff','#ff4d4d','#ffd400','#00e676','#00b0ff','#7c4dff','#ff6ec7','#ff8a00'];
let colorIdx = 0;
let brushSize = parseInt(sizeEl.value,10);
let erasing = false;

let strokes = [];
const currentStroke = {};
const lastPt = {};
const lastPinch = {};
const firedOnce = new Map();
const SMOOTH = 0.5;
const mirror = true;

/* MediaPipe */
let MP=null, FilesetResolver=null, HandLandmarker=null, handLandmarker=null;
let running = false;
let lastVideoTime = -1;

function setCanvasSize(){
  const rect = paint.getBoundingClientRect();
  W = Math.floor(rect.width);
  H = Math.floor(rect.height);
  paint.width = Math.floor(W*DPR);
  paint.height = Math.floor(H*DPR);
  paint.getContext('2d').setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', setCanvasSize);

/* UI */
palette.forEach((c,i)=>{
  const b=document.createElement('button');
  b.className='swatch'+(i===0?' active':''); b.style.background=c; b.title=c;
  b.addEventListener('click', ()=>{
    document.querySelectorAll('.swatch').forEach(s=>s.classList.remove('active'));
    b.classList.add('active'); colorIdx=i; erasing=false; eraserBtn.classList.toggle('toggled', erasing);
  });
  colorsEl.appendChild(b);
});
sizeEl.addEventListener('input', ()=>{ brushSize=parseInt(sizeEl.value,10); sizeLabel.textContent=brushSize+'px'; });
eraserBtn.addEventListener('click', ()=>{ erasing=!erasing; eraserBtn.classList.toggle('toggled', erasing); });
undoBtn.addEventListener('click', undo);
clearBtn.addEventListener('click', ()=>{ strokes=[]; redrawAll(); });
saveBtn.addEventListener('click', savePNG);

document.addEventListener('keydown',(e)=>{
  if(e.key==='e'||e.key==='E') eraserBtn.click();
  if(e.key==='u'||e.key==='U') undo();
  if(e.key==='c'||e.key==='C') cycleColor();
  if(e.key==='s'||e.key==='S') saveBtn.click();
  if(e.key===']'){ sizeEl.value=Math.min(100, parseInt(sizeEl.value,10)+1); sizeEl.dispatchEvent(new Event('input')); }
  if(e.key==='['){ sizeEl.value=Math.max(1, parseInt(sizeEl.value,10)-1); sizeEl.dispatchEvent(new Event('input')); }
  if(e.key==='h'||e.key==='H'){
    const help=document.querySelector('.help');
    const disp = getComputedStyle(help).display;
    help.style.display = (disp==='none' ? 'block' : 'none');
  }
});

/* Drawing core */
function beginStrokeKey(key,p){
  const stroke={points:[p], color:palette[colorIdx], size:brushSize, tool: erasing?'erase':'draw'};
  strokes.push(stroke);
  currentStroke[key]=stroke;
  drawDot(p, stroke);
}
function addPointKey(key,p){
  const sm = smooth(lastPt[key], p); lastPt[key]=sm;
  if(!currentStroke[key]){ beginStrokeKey(key, sm); return; }
  currentStroke[key].points.push(sm);
  const pts=currentStroke[key].points;
  drawSegment(pts[pts.length-2], sm, currentStroke[key]);
}
function endStrokeKey(key){ currentStroke[key]=null; lastPt[key]=null; }
function smooth(a,b){ if(!a) return b; return {x:a.x*(1-SMOOTH)+b.x*SMOOTH, y:a.y*(1-SMOOTH)+b.y*SMOOTH}; }
function ctxFor(stroke){
  const ctx = paint.getContext('2d');
  ctx.lineJoin = ctx.lineCap = 'round';
  ctx.lineWidth = stroke.size;
  if(stroke.tool==='erase'){ ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='rgba(0,0,0,1)'; }
  else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=stroke.color; }
  return ctx;
}
function drawDot(p, stroke){ const ctx=ctxFor(stroke); ctx.beginPath(); ctx.arc(p.x,p.y, stroke.size*0.5, 0, Math.PI*2); ctx.fillStyle = (stroke.tool==='erase'?'rgba(0,0,0,1)':stroke.color); ctx.fill(); }
function drawSegment(a,b,stroke){ const ctx=ctxFor(stroke); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
function redrawAll(){
  const ctx=paint.getContext('2d'); ctx.clearRect(0,0,W,H);
  for(const s of strokes){
    if(s.points.length===1){ drawDot(s.points[0], s); continue; }
    for(let i=1;i<s.points.length;i++){ drawSegment(s.points[i-1], s.points[i], s); }
  }
}
function undo(){ if(strokes.length===0) return; strokes.pop(); redrawAll(); }
function savePNG(){ const a=document.createElement('a'); a.download='hand-draw.png'; a.href=paint.toDataURL('image/png'); a.click(); }
function cycleColor(){
  colorIdx=(colorIdx+1)%palette.length;
  document.querySelectorAll('.swatch').forEach((s,i)=>s.classList.toggle('active', i===colorIdx));
  erasing=false; eraserBtn.classList.remove('toggled');
}
function cursorMove(i,p){ const c=cursors[i]; if(!c) return; c.hidden=false; c.style.left=p.x+'px'; c.style.top=p.y+'px'; }
function hideCursors(){ for(const c of cursors){ c.hidden=true; } }

/* Mouse fallback */
let mouseDown=false;
paint.addEventListener('pointerdown',(e)=>{ if(handLandmarker) return; mouseDown=true; beginStrokeKey('mouse', getPointer(e)); });
paint.addEventListener('pointermove',(e)=>{ if(handLandmarker) return; const p=getPointer(e); cursorMove(0,p); if(mouseDown) addPointKey('mouse', p); });
window.addEventListener('pointerup',()=>{ if(handLandmarker) return; if(mouseDown){ endStrokeKey('mouse'); mouseDown=false; } });
function getPointer(e){ const r=paint.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }

/* Camera */
async function initCam(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:{ideal:1280}, height:{ideal:720}}, audio:false});
    video.srcObject = stream;
    sCam.textContent='CAM OK'; sCam.className='pill ok';
    sMsg.textContent = '카메라 연결됨';
    await video.play();
  }catch(e){
    sCam.textContent='CAM ERR'; sCam.className='pill bad';
    sMsg.textContent = '카메라 접근 실패: '+e.message;
  }
}

/* MediaPipe load */
async function loadLib(){
  const bases=[
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18",
    "https://unpkg.com/@mediapipe/tasks-vision@0.10.18"
  ];
  let baseOk=null;
  for(const base of bases){
    try{ const mod=await import(base); MP=mod; FilesetResolver=mod.FilesetResolver; HandLandmarker=mod.HandLandmarker; baseOk=base; break; }
    catch(e){ console.warn('Lib load failed from', base, e); }
  }
  if(!baseOk){
    sLib.textContent='LIB ERR'; sLib.className='pill bad';
    sMsg.textContent='라이브러리 로드 실패(CDN 차단 가능).';
    return false;
  }
  sLib.textContent='LIB OK'; sLib.className='pill ok';
  sMsg.textContent='라이브러리 로드됨';
  try{
    const resolver = await FilesetResolver.forVisionTasks(baseOk + "/wasm");
    const models=[
      "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
      "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker_lite/float16/1/hand_landmarker_lite.task"
    ];
    let lastErr=null;
    for(const m of models){
      try{
        handLandmarker = await HandLandmarker.createFromOptions(resolver,{
          baseOptions:{ modelAssetPath:m },
          numHands:2,
          runningMode:"VIDEO",
          minTrackingConfidence:0.5,
          minDetectionConfidence:0.5
        });
        break;
      }catch(e){ lastErr=e; }
    }
    if(!handLandmarker) throw lastErr || new Error('모델 로드 실패');
    sModel.textContent='MODEL OK'; sModel.className='pill ok';
    sMsg.textContent='모델 로드됨';
    return true;
  }catch(e){
    console.warn(e);
    sModel.textContent='MODEL ERR'; sModel.className='pill bad';
    sMsg.textContent='모델 로드 실패(CDN/네트워크 문제일 수 있음)';
    return false;
  }
}

/* Helpers */
function normToCanvas(xNorm,yNorm){
  const x = (mirror? (1-xNorm) : xNorm) * W;
  const y = yNorm * H;
  return {x,y};
}
function pinchGesture(lms){
  const tips=[8,12,16,20]; const thumb=lms[4];
  let minX=1,minY=1,maxX=0,maxY=0;
  for(const p of lms){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
  const diag=Math.hypot(maxX-minX, maxY-minY);
  const thr=Math.max(0.06, Math.min(0.18, diag*0.17));
  let best={name:null, d:999};
  for(const t of tips){
    const d=Math.hypot(lms[t].x-thumb.x, lms[t].y-thumb.y);
    if(d<best.d){ best={name:(t===8?'index':t===12?'middle':t===16?'ring':'pinky'), d}; }
  }
  return best.d < thr ? best.name : null;
}
function markTracking(n){
  sTrack.textContent = `HANDS:${n}`;
  sTrack.className = 'pill '+(n>0?'ok':(handLandmarker?'warn':'bad'));
}

/* Main loop */
function step(){
  if(!running) return;
  const now = performance.now();
  if(video.readyState>=2){
    const vt=video.currentTime;
    if(vt !== lastVideoTime && handLandmarker){
      lastVideoTime = vt;
      const res = handLandmarker.detectForVideo(video, now);
      const n = (res?.landmarks?.length)||0;
      markTracking(n);

      hideCursors();
      if(n>0){
        for(let i=0;i<n;i++){
          const raw = res.landmarks[i];
          const key = (res.handednesses?.[i]?.[0]?.categoryName) || `H${i}`;

          const pIdx = normToCanvas(raw[8].x, raw[8].y);
          cursorMove(i, pIdx);

          const pinch = pinchGesture(raw);
          if(pinch){
            if(pinch !== lastPinch[key]){
              if(!firedOnce.has(key)) firedOnce.set(key, new Set());
              const once = firedOnce.get(key);
              if(pinch==='middle' && !once.has('eraser')){ erasing=!erasing; eraserBtn.classList.toggle('toggled', erasing); once.add('eraser'); }
              if(pinch==='ring' && !once.has('undo')){ undo(); once.add('undo'); }
              if(pinch==='pinky' && !once.has('color')){ cycleColor(); once.add('color'); }
            }
            lastPinch[key]=pinch;

            if(pinch==='index'){
              addPointKey(key, pIdx);
            }
          }else{
            firedOnce.delete(key);
            if(currentStroke[key]) endStrokeKey(key);
            lastPinch[key]=null;
          }
        }
      }else{
        hideCursors();
        Object.keys(currentStroke).forEach(k=>{ if(currentStroke[k]) endStrokeKey(k); });
      }
    }
  }
  (video.requestVideoFrameCallback ? video.requestVideoFrameCallback(step) : requestAnimationFrame(step));
}

/* Boot */
(async function main(){
  setCanvasSize();
  await initCam();
  await loadLib();
  running=true;
  (video.requestVideoFrameCallback ? video.requestVideoFrameCallback(step) : requestAnimationFrame(step));
})();
</script>
</body>
</html>
