<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>허공필(虛空筆) — Hand Pinch Draw</title>
  <style>
    :root {
      --panel: rgba(24,24,24,.8);
      --accent: #fff;
      --muted: #bbb;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; margin:0; background:#000; color:#fff; font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
    .app { display:grid; grid-template-rows:auto 1fr auto; height:100%; }
    header { padding:8px 12px; display:flex; align-items:center; gap:12px; }
    header .dot { width:8px; height:8px; border-radius:50%; background:#16a34a; }
    header .status { font-size:14px; color:var(--muted); }
    main { position: relative; display:flex; justify-content:center; align-items:center; padding:8px; }
    /* 비디오와 캔버스는 같은 래퍼 안에서 좌우반전 동기화 */
    .stage { position:relative; width:min(92vw, 960px); aspect-ratio:4/3; background:#111; border-radius:12px; overflow:hidden; }
    .mirror { transform: scaleX(-1); transform-origin:center; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; }
    #video { object-fit:cover; }
    #overlay { pointer-events:none; }
    #draw { pointer-events:none; }
    /* 우상단 도움말 */
    .help {
      position:absolute; right:12px; top:12px; padding:10px 12px; background:var(--panel);
      border:1px solid rgba(255,255,255,.12); border-radius:12px; font-size:13px; line-height:1.5;
      backdrop-filter: blur(6px);
    }
    .help b { display:block; margin-bottom:6px; font-weight:700; color:#fff; }
    /* 좌측 상단 툴 상태 */
    .tool {
      position:absolute; left:12px; top:12px; padding:8px 10px; background:var(--panel);
      border:1px solid rgba(255,255,255,.12); border-radius:12px; font-size:13px; display:flex; gap:10px; align-items:center; backdrop-filter: blur(6px);
    }
    .pill { padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14); }
    .on { background:#fff; color:#000; }
    footer {
      display:flex; gap:8px; padding:10px; justify-content:center; align-items:center; background:transparent;
    }
    button {
      background:#1f1f1f; color:#fff; border:1px solid rgba(255,255,255,.12);
      padding:10px 14px; border-radius:10px; font-size:14px; cursor:pointer;
    }
    button:hover { background:#262626; }
    .hint { font-size:12px; color:var(--muted); text-align:center; margin:2px 0 10px; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="dot" id="camDot"></div>
      <div class="status" id="status">카메라 초기화 중…</div>
    </header>

    <main>
      <div class="stage">
        <!-- 좌우반전은 같은 그룹에 함께 적용 -->
        <video id="video" class="mirror" autoplay playsinline muted></video>
        <!-- 드로잉 캔버스(사용자 그림), 오버레이 캔버스(골격/보조선) -->
        <canvas id="draw" class="mirror"></canvas>
        <canvas id="overlay" class="mirror"></canvas>

        <div class="tool" id="toolPanel">
          <span class="pill" id="modePill">모드: 드로잉</span>
          <span class="pill" id="colorPill">색상</span>
          <span class="pill" id="eraserPill">지우개: OFF</span>
        </div>

        <div class="help">
          <b>제스처</b>
          • 엄지+검지: 드로잉<br/>
          • 엄지+중지: 지우개 토글<br/>
          • 엄지+약지: 되돌리기<br/>
          • 엄지+소지: 색상 순환
        </div>
      </div>
    </main>

    <div class="hint">거리가 너무 멀면 손 인식이 약해져요. 화면 중앙, 어깨~가슴 높이에서 해보세요.</div>

    <footer>
      <button id="undoBtn">되돌리기</button>
      <button id="clearBtn">초기화</button>
      <button id="saveBtn">저장</button>
    </footer>
  </div>

  <script type="module">
    // Mediapipe Tasks Vision (ESM)
    import {
      FilesetResolver,
      HandLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/vision_bundle.js";

    const statusEl = document.getElementById("status");
    const camDot = document.getElementById("camDot");
    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const octx = overlay.getContext("2d");
    const draw = document.getElementById("draw");
    const dctx = draw.getContext("2d");

    const undoBtn = document.getElementById("undoBtn");
    const clearBtn = document.getElementById("clearBtn");
    const saveBtn = document.getElementById("saveBtn");
    const modePill = document.getElementById("modePill");
    const eraserPill = document.getElementById("eraserPill");
    const colorPill = document.getElementById("colorPill");

    // 색상 팔레트(쨍한 컬러)
    const COLORS = ["#ffffff", "#ff3b30", "#ff9500", "#ffcc00", "#34c759", "#0fd1ff", "#007aff", "#af52de", "#ff2d55"];
    let colorIndex = 0;
    function cycleColor() {
      colorIndex = (colorIndex + 1) % COLORS.length;
      colorPill.style.background = COLORS[colorIndex];
      colorPill.style.color = "#000";
    }
    cycleColor();

    // 상태
    let handLandmarker = null;
    let runningMode = "VIDEO";
    let lastVideoTime = -1;

    // 두 손 동시 지원을 위한 상태(핸드별)
    const handState = [
      { drawing:false, prevPinch:null }, // left or right #0
      { drawing:false, prevPinch:null }  // #1
    ];
    let eraserOn = false;

    // 스트로크 히스토리(Undo 지원)
    const strokes = []; // {points:[{x,y}], color, size, erase:boolean}
    const brushSize = 4;
    const eraserSize = 24;

    // 유틸
    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

    function fitCanvases() {
      // 비디오 메타데이터 로드 후 실제 크기에 맞춰 캔버스 크기 설정
      const rect = video.getBoundingClientRect();
      const width = overlay.width = draw.width = rect.width;
      const height = overlay.height = draw.height = rect.height;
      // 캔버스 스케일이 CSS와 동일하도록 DPI 반영
      const dpr = window.devicePixelRatio || 1;
      overlay.width = Math.round(width * dpr);
      overlay.height = Math.round(height * dpr);
      draw.width = Math.round(width * dpr);
      draw.height = Math.round(height * dpr);
      overlay.style.width = draw.style.width = width + "px";
      overlay.style.height = draw.style.height = height + "px";
      octx.setTransform(dpr,0,0,dpr,0,0);
      dctx.setTransform(dpr,0,0,dpr,0,0);
    }

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: {ideal: 1280}, height: {ideal: 960} },
        audio: false
      });
      video.srcObject = stream;
      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          video.play();
          camDot.style.background = "#16a34a";
          resolve();
        };
      });
    }

    async function setupHandLandmarker() {
      statusEl.textContent = "모델 로드 중…";
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          // 구글 공식 호스팅 모델(.task)
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
        },
        runningMode,
        numHands: 2,
        minHandDetectionConfidence: 0.6,
        minHandPresenceConfidence: 0.6,
        minTrackingConfidence: 0.5
      });

      statusEl.textContent = "준비 완료. 손을 화면에 보여주세요!";
    }

    function renderOverlay(results) {
      octx.clearRect(0,0,overlay.width, overlay.height);
      const drawer = new DrawingUtils(octx);

      if (!results || !results.landmarks) return;

      results.landmarks.forEach((lm, idx) => {
        // landmark는 정규화 좌표(0~1) → 픽셀로 변환
        // DrawingUtils가 자동으로 처리하므로 그대로 사용
        drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 2 });
        drawer.drawLandmarks(lm, { radius: 2.2 });
      });
    }

    function normalizedToPixel(point) {
      // 비디오 요소의 실제 렌더 크기 기준
      const rect = video.getBoundingClientRect();
      return { x: point.x * rect.width, y: point.y * rect.height };
    }

    function palmWidthNorm(lm) {
      // 손바닥 폭 (index mcp 5) ~ (pinky mcp 17) 사이 거리 (정규화 좌표 기준)
      const a = lm[5], b = lm[17];
      if (!a || !b) return 0.1;
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function detectPinchType(lm) {
      // 엄지(4)와 각 손가락 끝(8,12,16,20) 거리 기반
      const thumb = lm[4];
      const idx = lm[8], mid = lm[12], ring = lm[16], pinky = lm[20];
      if (!thumb || !idx || !mid || !ring || !pinky) return null;

      const base = palmWidthNorm(lm);
      const th = Math.max(0.03, base * 0.33); // 손 크기에 따른 가변 임계치

      const dI = Math.hypot(thumb.x - idx.x, thumb.y - idx.y);
      const dM = Math.hypot(thumb.x - mid.x, thumb.y - mid.y);
      const dR = Math.hypot(thumb.x - ring.x, thumb.y - ring.y);
      const dP = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y);

      const map = [
        {type:"index", d:dI},
        {type:"middle", d:dM},
        {type:"ring", d:dR},
        {type:"pinky", d:dP},
      ].sort((a,b)=>a.d-b.d);

      if (map[0].d < th) return map[0].type;
      return null;
    }

    function pushStrokePoint(x, y, color, size, erase=false) {
      // 현재 stroke가 없거나 모드 변경 시 새로 시작
      if (!strokes.length || strokes[strokes.length-1]._sealed) {
        strokes.push({ points: [], color, size, erase, _sealed:false });
      }
      const s = strokes[strokes.length-1];
      // 모드가 다르면 새 스트로크
      if (s.erase !== erase || s.color !== color || s.size !== size) {
        s._sealed = true;
        strokes.push({ points: [], color, size, erase, _sealed:false });
      }
      strokes[strokes.length-1].points.push({x, y});
      redrawStrokes();
    }

    function sealStroke() {
      if (strokes.length) strokes[strokes.length-1]._sealed = true;
    }

    function redrawStrokes() {
      dctx.clearRect(0,0,draw.width, draw.height);
      for (const s of strokes) {
        dctx.save();
        dctx.lineCap = "round";
        dctx.lineJoin = "round";
        dctx.lineWidth = s.size;
        if (s.erase) {
          dctx.globalCompositeOperation = "destination-out";
          dctx.strokeStyle = "rgba(0,0,0,1)";
        } else {
          dctx.globalCompositeOperation = "source-over";
          dctx.strokeStyle = s.color;
        }

        if (s.points.length === 1) {
          const p = s.points[0];
          dctx.beginPath();
          dctx.arc(p.x, p.y, s.size/2, 0, Math.PI*2);
          dctx.fillStyle = dctx.strokeStyle;
          dctx.fill();
        } else if (s.points.length > 1) {
          dctx.beginPath();
          dctx.moveTo(s.points[0].x, s.points[0].y);
          for (let i=1;i<s.points.length;i++){
            dctx.lineTo(s.points[i].x, s.points[i].y);
          }
          dctx.stroke();
        }
        dctx.restore();
      }
    }

    function undo() {
      // 마지막 스트로크 하나 제거
      strokes.pop();
      redrawStrokes();
    }

    function clearAll() {
      strokes.length = 0;
      dctx.clearRect(0,0,draw.width, draw.height);
    }

    function savePNG() {
      // 배경을 포함해 합성 저장
      const tmp = document.createElement("canvas");
      tmp.width = draw.width;
      tmp.height = draw.height;
      const tctx = tmp.getContext("2d");
      // 배경 검정
      tctx.fillStyle = "#000"; tctx.fillRect(0,0,tmp.width,tmp.height);
      // 드로잉만 복사
      tctx.drawImage(draw, 0, 0);
      const url = tmp.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url;
      a.download = "hand-pinch-draw.png";
      a.click();
    }

    undoBtn.onclick = () => undo();
    clearBtn.onclick = () => { clearAll(); };
    saveBtn.onclick = () => savePNG();

    function setEraser(on) {
      eraserOn = on;
      eraserPill.textContent = "지우개: " + (on ? "ON" : "OFF");
      eraserPill.classList.toggle("on", on);
      modePill.textContent = "모드: " + (on ? "지우개" : "드로잉");
      modePill.classList.toggle("on", !on);
    }

    async function main() {
      try {
        await setupCamera();
        statusEl.textContent = "카메라 연결됨";
        fitCanvases();
        window.addEventListener("resize", fitCanvases);
      } catch(e) {
        statusEl.textContent = "카메라 권한이 필요합니다.";
        camDot.style.background = "#ef4444";
        console.error(e);
        return;
      }

      try {
        await setupHandLandmarker();
      } catch(e) {
        statusEl.textContent = "모델 로드 실패. 네트워크를 확인하세요.";
        console.error(e);
        return;
      }

      // 프레임 루프
      const loop = () => {
        if (!handLandmarker) return;
        const now = performance.now();
        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          const results = handLandmarker.detectForVideo(video, now);
          renderOverlay(results);

          if (results && results.landmarks && results.landmarks.length) {
            statusEl.textContent = "손 인식됨: " + results.landmarks.length;
            results.landmarks.forEach((lm, i) => {
              const ht = detectPinchType(lm); // null | index | middle | ring | pinky

              // 핀치 이벤트(상승 에지) 처리
              if (handState[i].prevPinch === null && ht !== null) {
                if (ht === "middle") {
                  // 지우개 토글
                  setEraser(!eraserOn);
                } else if (ht === "ring") {
                  undo();
                } else if (ht === "pinky") {
                  cycleColor();
                }
              }

              // 드로잉 핀치 지속 처리
              if (ht === "index") {
                handState[i].drawing = true;
                const tip = normalizedToPixel(lm[8]); // 검지 끝
                // mirror가 적용돼 있으니 x를 좌우 반전해서 그림 좌표도 일치시킴
                const rect = video.getBoundingClientRect();
                const mirroredX = rect.width - tip.x;
                pushStrokePoint(mirroredX, tip.y, COLORS[colorIndex], eraserOn ? eraserSize : brushSize, eraserOn);
              } else {
                if (handState[i].drawing) {
                  // 핀치 종료 → 스트로크 고정
                  sealStroke();
                }
                handState[i].drawing = false;
              }

              handState[i].prevPinch = ht;
            });
          } else {
            statusEl.textContent = "손을 화면에 비춰주세요";
            // 진행 중이면 스트로크 닫기
            handState.forEach(s => { if (s.drawing) sealStroke(); s.drawing = false; s.prevPinch = null; });
          }
        }
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    main();
  </script>
</body>
</html>
