<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>한울의 허공필(虛空筆)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    :root{
      --ui-bg: rgba(20,20,20,.8);
      --ui-fg:#fff;
      --accent:#7dd3fc;
      --btn-border:#333;
      --x-nudge-y: -1.5px
    }
    *{ box-sizing:border-box; font-weight:inherit; }
    html,body{
      height:100%; margin:0; background:#000; color:#fff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Apple SD Gothic Neo,"Noto Sans KR",sans-serif;
      font-weight:700;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }

    /* 주소창 변동 대응 */
    .wrap{ position:relative; width:100%; height:100svh; overflow:hidden; background:#000; }

    video#video{
      position:absolute; inset:0; margin:auto; width:100%; height:100%; object-fit:cover;
      transform: scaleX(-1); filter:brightness(.9) contrast(1.1) saturate(1.05);
      opacity:.25; pointer-events:none;
    }
    canvas#paint{ position:absolute; inset:0; width:100%; height:100%; touch-action:none; }

    /* 상단: 좌 상태, 우 도움말 */
    .topline{
      position:absolute; top:12px;
      left:max(12px, env(safe-area-inset-left));
      right:max(12px, env(safe-area-inset-right));
      display:grid; grid-template-columns:auto 1fr auto; gap:8px; align-items:start;
      pointer-events:none;
    }

    .status{
      display:inline-flex; flex-direction:column; gap:8px;
      background:var(--ui-bg); color:var(--ui-fg);
      padding:10px 12px; border-radius:12px; font-size:12px; line-height:1.4;
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .status .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .status .msg{ opacity:.95; }

    .pill{ display:inline-block; padding:2px 6px; border-radius:999px; }
    .ok{background:#073}.warn{background:#735d00}.bad{background:#600}

    /* 도움말 패널 */
    .help{
      position:relative;
      background:var(--ui-bg); color:var(--ui-fg);
      padding:12px 14px; border-radius:12px; font-size:12px; line-height:1.45;
      max-width:min(420px,34vw); backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .help pre{ margin:0; font:inherit; white-space:pre-wrap; }
    .help-close{
      position:absolute; top:6px; right:6px; width:26px; height:26px;
      display:none; /* 기본(PC 포함) 숨김 */
      align-items:center; justify-content:center; border-radius:999px;
      background:transparent; color:#fff; border:1px solid var(--btn-border);
      line-height:1;
      cursor:pointer;
    }
    
    .help-close::before{
      content:"×";
      display:inline-block;
      font-size:16px;
      transform: translateY(var(--x-nudge-y)); 
    }

    .toolbar{
      position:absolute; left:50%; transform:translateX(-50%);
      bottom: calc(16px + env(safe-area-inset-bottom));
      display:flex; gap:10px; align-items:center; justify-content:center;
      background:var(--ui-bg); color:var(--ui-fg); padding:10px 12px; border-radius:14px;
      backdrop-filter: blur(10px); box-shadow: 0 6px 20px rgba(0,0,0,.35); user-select:none;
      max-width:min(96vw, 960px);
      flex-wrap:nowrap;
    }
    .colors{display:flex; gap:6px;}
    .swatch{
      width:22px;height:22px;border-radius:50%; cursor:pointer; border:2px solid rgba(255,255,255,.6);
      outline:2px solid transparent; outline-offset:2px;
    }
    .swatch.active{ outline-color:var(--accent) }
    .group{display:flex;gap:8px;align-items:center}
    .group.size{}
    .group.actions{}
    .btn{ height:32px; padding:0 10px; border-radius:10px; background:#111; color:#fff; border:1px solid var(--btn-border); cursor:pointer; }
    .btn.ghost{ background:transparent; border:1px solid var(--btn-border); }
    .btn.toggled{ outline:2px solid var(--accent); outline-offset:2px; }
    .slider{ width:120px; accent-color:var(--accent); }
    .sep{width:1px;height:22px;background:#444; margin:0 4px}
    .cursor{
      position:absolute; width:14px;height:14px;border:2px solid #fff;border-radius:50%; pointer-events:none;
      transform:translate(-50%,-50%); mix-blend-mode:difference;
    }

    /* 작은 화면 기본 */
    @media (max-width: 1024px){ }
    @media (max-width: 720px){
      .slider{ width:90px }
      .help{ display:none } /* 기본 숨김(모바일은 i 버튼으로 토글) */
    }

    /* ===== 모바일 모드(UA/폭 감지로 body.mobile 추가) ===== */
    body.mobile .topline{
      grid-template-columns:1fr; justify-items:center; /* CAM/LIB/MODEL/HANDS 중앙 */
    }
    body.mobile .status{ text-align:center; }

    /* 8px 라벨 중앙 & 구분선 제거 & 버튼 한 줄 */
    body.mobile .toolbar{
      gap:8px; padding:8px 10px; border-radius:12px; max-width:min(96vw, 720px); flex-wrap:wrap;
      font-size:12px;
    }
    body.mobile .group.size{ flex:0 0 100%; justify-content:center; } /* 슬라이더+8px 중앙 */
    body.mobile .sep{ display:none; } /* 모바일에서 | 제거 */
    body.mobile .group.actions{ flex-wrap:nowrap; white-space:nowrap; } /* 버튼 한 줄 강제 */
    body.mobile .btn{ height:30px; padding:0 8px; font-size:12px; }

    /* 도움말 아이콘: 모바일에서 우하단 */
    .info-btn{
      position:absolute; z-index:60;
      width:36px; height:36px; border-radius:999px;
      background:var(--ui-bg); color:#fff; border:1px solid var(--btn-border);
      display:none; align-items:center; justify-content:center; font-weight:900;
      pointer-events:auto; backdrop-filter:blur(8px);
      top:12px; right:max(12px, env(safe-area-inset-right)); /* 기본(데스크톱) */
    }
    body.mobile .info-btn{
      top:auto;
      right:max(16px, env(safe-area-inset-right));
      bottom: calc(16px + env(safe-area-inset-bottom));
      display:flex;
    }

    /* 도움말 모달: 중앙 + 모바일에서만 X 보임 */
    body.mobile .help{ display:none !important; }
    body.mobile .help.show{
      display:block !important; position:fixed; z-index:70;
      left:50%; top:50%; transform:translate(-50%,-50%);
      width:min(88vw, 420px); max-width:420px; max-height:70vh; overflow:auto;
    }
    body.mobile .help.show .help-close{ display:flex; } /* 모바일+열림일 때만 X 보임 */
  </style>
</head>
<body>
<div class="wrap" id="app">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="paint"></canvas>

  <!-- 상단 UI -->
  <div class="topline">
    <div class="status" id="statusBox">
      <div class="row">
        <span class="pill ok" id="sCam">CAM?</span>
        <span class="pill bad" id="sLib">LIB</span>
        <span class="pill bad" id="sModel">MODEL</span>
        <span class="pill bad" id="sTrack">HANDS:0</span>
      </div>
      <div class="msg" id="sMsg">초기화 중…</div>
    </div>

    <div></div>

    <div class="help" id="helpPanel">
      <button class="help-close" id="helpClose" aria-label="도움말 닫기" title="닫기"></button>
      <pre><span style="color: #ffd400;">손동작 안내</span>
• 엄지+검지: 그리기
• 엄지+중지: 지우개 토글
• 엄지+약지: 되돌리기
• 엄지+소지: 색상 순환</pre>
    </div>
  </div>

  <!-- 모바일: 도움말 토글 i 버튼 (우하단) -->
  <button id="infoBtn" class="info-btn" aria-label="도움말" title="도움말">i</button>

  <!-- 손가락 위치 표시용 커서 -->
  <div class="cursor" id="cursor0" hidden></div>
  <div class="cursor" id="cursor1" hidden></div>

  <div class="toolbar">
    <div class="group colors" id="colors"></div>

    <!-- 슬라이더 그룹: 중앙 정렬 위해 .size 클래스 부여 -->
    <div class="group size">
      <input type="range" id="size" class="slider" min="1" max="100" value="8" />
      <span id="sizeLabel">8px</span>
    </div>

    <div class="sep"></div>

    <!-- 버튼 묶음: 한 줄 유지 위해 .actions 클래스 부여 -->
    <div class="group actions">
      <button class="btn" id="eraserBtn" title="E">지우개</button>
      <button class="btn ghost" id="undoBtn" title="U">되돌리기</button>
      <button class="btn ghost" id="clearBtn">초기화</button>
      <button class="btn" id="saveBtn" title="S">저장</button>
    </div>
  </div>
</div>

<script type="module">
/* 기본 참조 */
const el = (id)=>document.getElementById(id);
const video = el('video'), paint = el('paint');
const sCam = el('sCam'), sLib=el('sLib'), sModel=el('sModel'), sTrack=el('sTrack'), sMsg=el('sMsg');
const colorsEl = el('colors'), sizeEl=el('size'), sizeLabel=el('sizeLabel');
const eraserBtn = el('eraserBtn'), undoBtn=el('undoBtn'), clearBtn=el('clearBtn'), saveBtn=el('saveBtn');
const helpPanel = el('helpPanel'), infoBtn = el('infoBtn'), helpClose = el('helpClose');
const cursors = [el('cursor0'), el('cursor1')];

const DPR = Math.min(2, window.devicePixelRatio || 1);
let W=0, H=0;

/* Drawing State */
const palette = ['#ffffff','#ff4d4d','#ffd400','#00e676','#00b0ff','#7c4dff','#ff6ec7','#ff8a00'];
let colorIdx = 0;
let brushSize = parseInt(sizeEl.value,10);
let erasing = false;

let strokes = [];
const currentStroke = {};
const lastPt = {};
const lastPinch = {};
const firedOnce = new Map();
const SMOOTH = 0.5;
const mirror = true;

/* MediaPipe */
let MP=null, FilesetResolver=null, HandLandmarker=null, handLandmarker=null;
let running = false;
let lastVideoTime = -1;

/* 캔버스 크기(주소창/회전 대응) */
function setCanvasSize(){
  const wrap = document.getElementById('app');
  const vw = wrap.clientWidth;
  const vh = (window.visualViewport ? window.visualViewport.height : wrap.clientHeight);
  W = Math.floor(vw);
  H = Math.floor(vh);
  paint.width = Math.floor(W*DPR);
  paint.height = Math.floor(H*DPR);
  const ctx = paint.getContext('2d');
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', setCanvasSize);

/* UI */
palette.forEach((c,i)=>{
  const b=document.createElement('button');
  b.className='swatch'+(i===0?' active':''); b.style.background=c; b.title=c;
  b.addEventListener('click', ()=>{
    document.querySelectorAll('.swatch').forEach(s=>s.classList.remove('active'));
    b.classList.add('active'); colorIdx=i; erasing=false; eraserBtn.classList.toggle('toggled', erasing);
  });
  colorsEl.appendChild(b);
});
sizeEl.addEventListener('input', ()=>{ brushSize=parseInt(sizeEl.value,10); sizeLabel.textContent=brushSize+'px'; });
eraserBtn.addEventListener('click', ()=>{ erasing=!erasing; eraserBtn.classList.toggle('toggled', erasing); });
undoBtn.addEventListener('click', undo);
clearBtn.addEventListener('click', ()=>{ strokes=[]; redrawAll(); });
saveBtn.addEventListener('click', savePNG);

document.addEventListener('keydown',(e)=>{
  if(e.key==='e'||e.key==='E') eraserBtn.click();
  if(e.key==='u'||e.key==='U') undo();
  if(e.key==='c'||e.key==='C') cycleColor();
  if(e.key==='s'||e.key==='S') saveBtn.click();
  if(e.key===']'){ sizeEl.value=Math.min(100, parseInt(sizeEl.value,10)+1); sizeEl.dispatchEvent(new Event('input')); }
  if(e.key==='['){ sizeEl.value=Math.max(1, parseInt(sizeEl.value,10)-1); sizeEl.dispatchEvent(new Event('input')); }
});

/* 도움말 토글 */
if (infoBtn && helpPanel){
  infoBtn.addEventListener('click', ()=> helpPanel.classList.toggle('show'));
}
if (helpClose){
  helpClose.addEventListener('click', ()=> helpPanel.classList.remove('show'));
}

/* Drawing core */
function beginStrokeKey(key,p){
  const stroke={points:[p], color:palette[colorIdx], size:brushSize, tool: erasing?'erase':'draw'};
  strokes.push(stroke);
  currentStroke[key]=stroke;
  drawDot(p, stroke);
}
function addPointKey(key,p){
  const sm = smooth(lastPt[key], p); lastPt[key]=sm;
  if(!currentStroke[key]){ beginStrokeKey(key, sm); return; }
  currentStroke[key].points.push(sm);
  const pts=currentStroke[key].points;
  drawSegment(pts[pts.length-2], sm, currentStroke[key]);
}
function endStrokeKey(key){ currentStroke[key]=null; lastPt[key]=null; }
function smooth(a,b){ if(!a) return b; return {x:a.x*(1-SMOOTH)+b.x*SMOOTH, y:a.y*(1-SMOOTH)+b.y*SMOOTH}; }
function ctxFor(stroke){
  const ctx = paint.getContext('2d');
  ctx.lineJoin = ctx.lineCap = 'round';
  ctx.lineWidth = stroke.size;
  if(stroke.tool==='erase'){ ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='rgba(0,0,0,1)'; }
  else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=stroke.color; }
  return ctx;
}
function drawDot(p, stroke){ const ctx=ctxFor(stroke); ctx.beginPath(); ctx.arc(p.x,p.y, stroke.size*0.5, 0, Math.PI*2); ctx.fillStyle = (stroke.tool==='erase'?'rgba(0,0,0,1)':stroke.color); ctx.fill(); }
function drawSegment(a,b,stroke){ const ctx=ctxFor(stroke); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
function redrawAll(){
  const ctx=paint.getContext('2d'); ctx.clearRect(0,0,W,H);
  for(const s of strokes){
    if(s.points.length===1){ drawDot(s.points[0], s); continue; }
    for(let i=1;i<s.points.length;i++){ drawSegment(s.points[i-1], s.points[i], s); }
  }
}
function undo(){ if(strokes.length===0) return; strokes.pop(); redrawAll(); }
function savePNG(){ const a=document.createElement('a'); a.download='hand-draw.png'; a.href=paint.toDataURL('image/png'); a.click(); }
function cycleColor(){
  colorIdx=(colorIdx+1)%palette.length;
  document.querySelectorAll('.swatch').forEach((s,i)=>s.classList.toggle('active', i===colorIdx));
  erasing=false; eraserBtn.classList.remove('toggled');
}
function cursorMove(i,p){ const c=cursors[i]; if(!c) return; c.hidden=false; c.style.left=p.x+'px'; c.style.top=p.y+'px'; }
function hideCursors(){ for(const c of cursors){ c.hidden=true; } }

/* 마우스 대체 */
let mouseDown=false;
paint.addEventListener('pointerdown',(e)=>{ if(handLandmarker) return; mouseDown=true; beginStrokeKey('mouse', getPointer(e)); });
paint.addEventListener('pointermove',(e)=>{ if(handLandmarker) return; const p=getPointer(e); cursorMove(0,p); if(mouseDown) addPointKey('mouse', p); });
window.addEventListener('pointerup',()=>{ if(handLandmarker) return; if(mouseDown){ endStrokeKey('mouse'); mouseDown=false; } });
function getPointer(e){ const r=paint.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }

/* 카메라 */
async function initCam(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:{ideal:1280}, height:{ideal:720}}, audio:false});
    video.srcObject = stream;
    sCam.textContent='CAM OK'; sCam.className='pill ok';
    sMsg.textContent = '카메라 연결됨';
    await video.play();
  }catch(e){
    sCam.textContent='CAM ERR'; sCam.className='pill bad';
    sMsg.textContent = '카메라 접근 실패: '+e.message;
  }
}

/* MediaPipe */
async function loadLib(){
  const bases=[
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18",
    "https://unpkg.com/@mediapipe/tasks-vision@0.10.18"
  ];
  let baseOk=null;
  for(const base of bases){
    try{ const mod=await import(base); MP=mod; FilesetResolver=mod.FilesetResolver; HandLandmarker=mod.HandLandmarker; baseOk=base; break; }
    catch(e){ console.warn('Lib load failed from', base, e); }
  }
  if(!baseOk){
    sLib.textContent='LIB ERR'; sLib.className='pill bad';
    sMsg.textContent='라이브러리 로드 실패(CDN 차단 가능).';
    return false;
  }
  sLib.textContent='LIB OK'; sLib.className='pill ok';
  sMsg.textContent='라이브러리 로드됨';
  try{
    const resolver = await FilesetResolver.forVisionTasks(baseOk + "/wasm");
    const models=[
      "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
      "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker_lite/float16/1/hand_landmarker_lite.task"
    ];
    let lastErr=null;
    for(const m of models){
      try{
        handLandmarker = await HandLandmarker.createFromOptions(resolver,{
          baseOptions:{ modelAssetPath:m },
          numHands:2,
          runningMode:"VIDEO",
          minTrackingConfidence:0.5,
          minDetectionConfidence:0.5
        });
        break;
      }catch(e){ lastErr=e; }
    }
    if(!handLandmarker) throw lastErr || new Error('모델 로드 실패');
    sModel.textContent='MODEL OK'; sModel.className='pill ok';
    sMsg.textContent='모델 로드됨';
    return true;
  }catch(e){
    console.warn(e);
    sModel.textContent='MODEL ERR'; sModel.className='pill bad';
    sMsg.textContent='모델 로드 실패(CDN/네트워크 문제일 수 있음)';
    return false;
  }
}

/* Helper */
function normToCanvas(xNorm,yNorm){
  const x = (mirror? (1-xNorm) : xNorm) * W;
  const y = yNorm * H;
  return {x,y};
}
function pinchGesture(lms){
  const tips=[8,12,16,20]; const thumb=lms[4];
  let minX=1,minY=1,maxX=0,maxY=0;
  for(const p of lms){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
  const diag=Math.hypot(maxX-minX, maxY-minY);
  const thr=Math.max(0.06, Math.min(0.18, diag*0.17));
  let best={name:null, d:999};
  for(const t of tips){
    const d=Math.hypot(lms[t].x-thumb.x, lms[t].y-thumb.y);
    if(d<best.d){ best={name:(t===8?'index':t===12?'middle':t===16?'ring':'pinky'), d}; }
  }
  return best.d < thr ? best.name : null;
}
function markTracking(n){
  sTrack.textContent = `HANDS:${n}`;
  sTrack.className = 'pill '+(n>0?'ok':(handLandmarker?'warn':'bad'));
}

/* 루프 */
function step(){
  if(!running) return;
  const now = performance.now();
  if(video.readyState>=2){
    const vt=video.currentTime;
    if(vt !== lastVideoTime && handLandmarker){
      lastVideoTime = vt;
      const res = handLandmarker.detectForVideo(video, now);
      const n = (res?.landmarks?.length)||0;
      markTracking(n);

      hideCursors();
      if(n>0){
        for(let i=0;i<n;i++){
          const raw = res.landmarks[i];
          const key = (res.handednesses?.[i]?.[0]?.categoryName) || `H${i}`;

          const pIdx = normToCanvas(raw[8].x, raw[8].y);
          cursorMove(i, pIdx);

          const pinch = pinchGesture(raw);
          if(pinch){
            if(pinch !== lastPinch[key]){
              if(!firedOnce.has(key)) firedOnce.set(key, new Set());
              const once = firedOnce.get(key);
              if(pinch==='middle' && !once.has('eraser')){ erasing=!erasing; eraserBtn.classList.toggle('toggled', erasing); once.add('eraser'); }
              if(pinch==='ring' && !once.has('undo')){ undo(); once.add('undo'); }
              if(pinch==='pinky' && !once.has('color')){ cycleColor(); once.add('color'); }
            }
            lastPinch[key]=pinch;

            if(pinch==='index'){
              addPointKey(key, pIdx);
            }
          }else{
            firedOnce.delete(key);
            if(currentStroke[key]) endStrokeKey(key);
            lastPinch[key]=null;
          }
        }
      }else{
        hideCursors();
        Object.keys(currentStroke).forEach(k=>{ if(currentStroke[k]) endStrokeKey(k); });
      }
    }
  }
  (video.requestVideoFrameCallback ? video.requestVideoFrameCallback(step) : requestAnimationFrame(step));
}

/* 모바일 감지 & 레이아웃 */
const isMobile = (() => {
  const ua = navigator.userAgent || navigator.vendor || window.opera;
  const touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  return /Mobi|Android|iPhone|iPad|iPod/i.test(ua) || (touch && Math.min(window.innerWidth, window.innerHeight) < 820);
})();
if (isMobile) { document.body.classList.add('mobile'); }

/* viewport 변화/회전 대응 */
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', () => setCanvasSize());
}
window.addEventListener('orientationchange', () => setTimeout(setCanvasSize, 250));

/* 부팅 */
(async function main(){
  setCanvasSize();
  await initCam();
  await loadLib();
  running=true;
  (video.requestVideoFrameCallback ? video.requestVideoFrameCallback(step) : requestAnimationFrame(step));
})();
</script>
</body>
</html>
